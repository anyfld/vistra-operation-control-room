// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: v1/ptz_service.proto

package protov1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/anyfld/vistra-operation-control-room/gen/proto/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// PTZServiceName is the fully-qualified name of the PTZService service.
	PTZServiceName = "v1.PTZService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// PTZServicePollingProcedure is the fully-qualified name of the PTZService's Polling RPC.
	PTZServicePollingProcedure = "/v1.PTZService/Polling"
	// PTZServiceSendPTZCommandProcedure is the fully-qualified name of the PTZService's SendPTZCommand
	// RPC.
	PTZServiceSendPTZCommandProcedure = "/v1.PTZService/SendPTZCommand"
	// PTZServiceSendCinematicCommandProcedure is the fully-qualified name of the PTZService's
	// SendCinematicCommand RPC.
	PTZServiceSendCinematicCommandProcedure = "/v1.PTZService/SendCinematicCommand"
	// PTZServiceGetQueueStatusProcedure is the fully-qualified name of the PTZService's GetQueueStatus
	// RPC.
	PTZServiceGetQueueStatusProcedure = "/v1.PTZService/GetQueueStatus"
)

// PTZServiceClient is a client for the v1.PTZService service.
type PTZServiceClient interface {
	// FD → CR: ポーリング・完了通知の統合エンドポイント
	// FDは定期的（デフォルト500ms間隔）にこのエンドポイントを呼び出し、
	// タスク完了時は即座に呼び出します。
	Polling(context.Context, *connect.Request[v1.PollingRequest]) (*connect.Response[v1.PollingResponse], error)
	// EP → CR: PTZ枠命令送信 (Layer 1: 高優先度)
	// PTZ命令は到着時にLayer 2（シネマティック枠）を全て破棄・中断します。
	SendPTZCommand(context.Context, *connect.Request[v1.SendPTZCommandRequest]) (*connect.Response[v1.SendPTZCommandResponse], error)
	// EP → CR: シネマティック枠命令送信 (Layer 2: 低優先度)
	// PTZ枠が空の時のみ実行されます。
	SendCinematicCommand(context.Context, *connect.Request[v1.SendCinematicCommandRequest]) (*connect.Response[v1.SendCinematicCommandResponse], error)
	// CR のキュー状態を取得
	GetQueueStatus(context.Context, *connect.Request[v1.GetQueueStatusRequest]) (*connect.Response[v1.GetQueueStatusResponse], error)
}

// NewPTZServiceClient constructs a client for the v1.PTZService service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewPTZServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) PTZServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	pTZServiceMethods := v1.File_v1_ptz_service_proto.Services().ByName("PTZService").Methods()
	return &pTZServiceClient{
		polling: connect.NewClient[v1.PollingRequest, v1.PollingResponse](
			httpClient,
			baseURL+PTZServicePollingProcedure,
			connect.WithSchema(pTZServiceMethods.ByName("Polling")),
			connect.WithClientOptions(opts...),
		),
		sendPTZCommand: connect.NewClient[v1.SendPTZCommandRequest, v1.SendPTZCommandResponse](
			httpClient,
			baseURL+PTZServiceSendPTZCommandProcedure,
			connect.WithSchema(pTZServiceMethods.ByName("SendPTZCommand")),
			connect.WithClientOptions(opts...),
		),
		sendCinematicCommand: connect.NewClient[v1.SendCinematicCommandRequest, v1.SendCinematicCommandResponse](
			httpClient,
			baseURL+PTZServiceSendCinematicCommandProcedure,
			connect.WithSchema(pTZServiceMethods.ByName("SendCinematicCommand")),
			connect.WithClientOptions(opts...),
		),
		getQueueStatus: connect.NewClient[v1.GetQueueStatusRequest, v1.GetQueueStatusResponse](
			httpClient,
			baseURL+PTZServiceGetQueueStatusProcedure,
			connect.WithSchema(pTZServiceMethods.ByName("GetQueueStatus")),
			connect.WithClientOptions(opts...),
		),
	}
}

// pTZServiceClient implements PTZServiceClient.
type pTZServiceClient struct {
	polling              *connect.Client[v1.PollingRequest, v1.PollingResponse]
	sendPTZCommand       *connect.Client[v1.SendPTZCommandRequest, v1.SendPTZCommandResponse]
	sendCinematicCommand *connect.Client[v1.SendCinematicCommandRequest, v1.SendCinematicCommandResponse]
	getQueueStatus       *connect.Client[v1.GetQueueStatusRequest, v1.GetQueueStatusResponse]
}

// Polling calls v1.PTZService.Polling.
func (c *pTZServiceClient) Polling(ctx context.Context, req *connect.Request[v1.PollingRequest]) (*connect.Response[v1.PollingResponse], error) {
	return c.polling.CallUnary(ctx, req)
}

// SendPTZCommand calls v1.PTZService.SendPTZCommand.
func (c *pTZServiceClient) SendPTZCommand(ctx context.Context, req *connect.Request[v1.SendPTZCommandRequest]) (*connect.Response[v1.SendPTZCommandResponse], error) {
	return c.sendPTZCommand.CallUnary(ctx, req)
}

// SendCinematicCommand calls v1.PTZService.SendCinematicCommand.
func (c *pTZServiceClient) SendCinematicCommand(ctx context.Context, req *connect.Request[v1.SendCinematicCommandRequest]) (*connect.Response[v1.SendCinematicCommandResponse], error) {
	return c.sendCinematicCommand.CallUnary(ctx, req)
}

// GetQueueStatus calls v1.PTZService.GetQueueStatus.
func (c *pTZServiceClient) GetQueueStatus(ctx context.Context, req *connect.Request[v1.GetQueueStatusRequest]) (*connect.Response[v1.GetQueueStatusResponse], error) {
	return c.getQueueStatus.CallUnary(ctx, req)
}

// PTZServiceHandler is an implementation of the v1.PTZService service.
type PTZServiceHandler interface {
	// FD → CR: ポーリング・完了通知の統合エンドポイント
	// FDは定期的（デフォルト500ms間隔）にこのエンドポイントを呼び出し、
	// タスク完了時は即座に呼び出します。
	Polling(context.Context, *connect.Request[v1.PollingRequest]) (*connect.Response[v1.PollingResponse], error)
	// EP → CR: PTZ枠命令送信 (Layer 1: 高優先度)
	// PTZ命令は到着時にLayer 2（シネマティック枠）を全て破棄・中断します。
	SendPTZCommand(context.Context, *connect.Request[v1.SendPTZCommandRequest]) (*connect.Response[v1.SendPTZCommandResponse], error)
	// EP → CR: シネマティック枠命令送信 (Layer 2: 低優先度)
	// PTZ枠が空の時のみ実行されます。
	SendCinematicCommand(context.Context, *connect.Request[v1.SendCinematicCommandRequest]) (*connect.Response[v1.SendCinematicCommandResponse], error)
	// CR のキュー状態を取得
	GetQueueStatus(context.Context, *connect.Request[v1.GetQueueStatusRequest]) (*connect.Response[v1.GetQueueStatusResponse], error)
}

// NewPTZServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewPTZServiceHandler(svc PTZServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	pTZServiceMethods := v1.File_v1_ptz_service_proto.Services().ByName("PTZService").Methods()
	pTZServicePollingHandler := connect.NewUnaryHandler(
		PTZServicePollingProcedure,
		svc.Polling,
		connect.WithSchema(pTZServiceMethods.ByName("Polling")),
		connect.WithHandlerOptions(opts...),
	)
	pTZServiceSendPTZCommandHandler := connect.NewUnaryHandler(
		PTZServiceSendPTZCommandProcedure,
		svc.SendPTZCommand,
		connect.WithSchema(pTZServiceMethods.ByName("SendPTZCommand")),
		connect.WithHandlerOptions(opts...),
	)
	pTZServiceSendCinematicCommandHandler := connect.NewUnaryHandler(
		PTZServiceSendCinematicCommandProcedure,
		svc.SendCinematicCommand,
		connect.WithSchema(pTZServiceMethods.ByName("SendCinematicCommand")),
		connect.WithHandlerOptions(opts...),
	)
	pTZServiceGetQueueStatusHandler := connect.NewUnaryHandler(
		PTZServiceGetQueueStatusProcedure,
		svc.GetQueueStatus,
		connect.WithSchema(pTZServiceMethods.ByName("GetQueueStatus")),
		connect.WithHandlerOptions(opts...),
	)
	return "/v1.PTZService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case PTZServicePollingProcedure:
			pTZServicePollingHandler.ServeHTTP(w, r)
		case PTZServiceSendPTZCommandProcedure:
			pTZServiceSendPTZCommandHandler.ServeHTTP(w, r)
		case PTZServiceSendCinematicCommandProcedure:
			pTZServiceSendCinematicCommandHandler.ServeHTTP(w, r)
		case PTZServiceGetQueueStatusProcedure:
			pTZServiceGetQueueStatusHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedPTZServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedPTZServiceHandler struct{}

func (UnimplementedPTZServiceHandler) Polling(context.Context, *connect.Request[v1.PollingRequest]) (*connect.Response[v1.PollingResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("v1.PTZService.Polling is not implemented"))
}

func (UnimplementedPTZServiceHandler) SendPTZCommand(context.Context, *connect.Request[v1.SendPTZCommandRequest]) (*connect.Response[v1.SendPTZCommandResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("v1.PTZService.SendPTZCommand is not implemented"))
}

func (UnimplementedPTZServiceHandler) SendCinematicCommand(context.Context, *connect.Request[v1.SendCinematicCommandRequest]) (*connect.Response[v1.SendCinematicCommandResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("v1.PTZService.SendCinematicCommand is not implemented"))
}

func (UnimplementedPTZServiceHandler) GetQueueStatus(context.Context, *connect.Request[v1.GetQueueStatusRequest]) (*connect.Response[v1.GetQueueStatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("v1.PTZService.GetQueueStatus is not implemented"))
}
